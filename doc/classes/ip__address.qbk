[section:ip__address Class [^ip::address]]

  namespace std {
    namespace net {
      namespace ip {

        class address
        {
        public:
          // constructors:
          address() noexcept;
          address(const address& a) noexcept;
          template <class T> address(const T& t) noexcept(``['see below]``);

          // assignment:
          address& operator=(const address& a) noexcept;

          // members:
          bool is_unspecified() const noexcept;
          bool is_loopback() const noexcept;
          bool is_multicast() const noexcept;
          bool is_v4() const noexcept;
          bool is_v6() const noexcept;
          string to_string() const;
          string to_string(error_code& ec) const;

          // static members:
          static address from_string(const string& str);
          static address from_string(const string& str, error_code& ec);
        };

        // address comparisons:
        bool operator==(const address& a, const address& b) noexcept;
        bool operator!=(const address& a, const address& b) noexcept;
        bool operator< (const address& a, const address& b) noexcept;
        bool operator> (const address& a, const address& b) noexcept;
        bool operator<=(const address& a, const address& b) noexcept;
        bool operator>=(const address& a, const address& b) noexcept;

        // address I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>& os, const address& addr);

      } // namespace ip
    } // namespace net
  } // namespace std

[section [^ip::address] constructors]

  address() noexcept;

[function_effects Constructs an object of class `address`.]

[function_postconditions The postconditions of this function are indicated in
the table below.]

[table address::address() effects
  [[expression][value]]
  [
    [`is_v4()`]
    [`true`]
  ]
  [
    [`is_v6()`]
    [`false`]
  ]
  [
    [`is_unspecified()`]
    [`true`]
  ]
]

  address(const address& a);

[function_effects Constructs an object of class `address`.]

[function_postconditions `*this == a`]

  template <class T> address(const T& t) noexcept(``['see below]``);

[function_remarks This constructor shall not participate in overload resolution
unless `is_same<T, address>::value` is `false`, and the expression
`address_cast<address>(t)` is valid and yields an rvalue of type `address`. The
expression inside `noexcept` shall be equivalent to
`noexcept(address_cast<address>(t))`.]

[function_effects Constructs an object of type `address` with the result of the
expression `address_cast<address>(t)`.]

[function_throws Nothing unless the expression `address_cast<address>(t)`
throws an exception.]

[endsect]

[section [^ip::address] assignment]

  address& operator=(const address& a);

[function_postconditions `*this == a`]

[function_returns `*this`]

[endsect]

[section [^ip::address] members]

  bool is_unspecified() const noexcept;

[function_returns `is_v4() ? address_v4(*this).is_unspecified() : address_v6(*this).is_unspecified()`.]

  bool is_loopback() const noexcept;

[function_returns `is_v4() ? address_v4(*this).is_loopback() : address_v6(*this).is_loopback()`.]

  bool is_multicast() const noexcept;

[function_returns `is_v4() ? address_v4(*this).is_multicast() : address_v6(*this).is_multicast()`.]

  bool is_v4() const noexcept;

[function_returns `true` if the object contains an IP version 4 address.]

  bool is_v6() const noexcept;

[function_returns `true` if the object contains an IP version 6 address.]

  string to_string() const;
  string to_string(error_code& ec) const;

[function_returns `is_v4() ? address_v4(*this).to_string(ec) : address_v6(*this).to_string(ec)`.]

[endsect]

[section [^ip::address] static members]

  static address from_string(const string& str);
  static address from_string(const string& str, error_code& ec);

[function_effects Converts a string representation of an address into an object
of class `address`, as if by calling:
``
  address a;
  address_v6 v6a = address_v6::from_string(str, ec);
  if (!ec)
    a = v6a;
  else
  {
    address_v4 v4a = address_v4::from_string(str, ec);
    if (!ec)
      a = v4a;
  }
``]

[function_returns `a`.]

[endsect]

[section [^ip::address] comparisons]

  bool operator==(const address& a, const address& b) noexcept;

[function_returns `(a.is_v4() && b.is_v4() && address_v4(a) == address_v4(b)) ||
(a.is_v6() && b.is_v6() && address_v6(a) == address_v6(b))`.]

  bool operator!=(const address& a, const address& b) noexcept;

[function_returns `!(a == b)`.]

  bool operator< (const address& a, const address& b) noexcept;

[function_returns `(a.is_v4() && b.is_v4() && address_v4(a) < address_v4(b)) ||
(a.is_v6() && b.is_v6() && address_v6(a) < address_v6(b)) ||
(a.is_v4() && b.is_v6())`.]

  bool operator> (const address& a, const address& b) noexcept;

[function_returns `b < a`.]

  bool operator<=(const address& a, const address& b) noexcept;
  
[function_returns `!(b < a)`.]

  bool operator>=(const address& a, const address& b) noexcept;

[function_returns `!(a < b)`.]

[endsect]

[section [^ip::address] I/O]

  template<class CharT, class Traits>
    basic_ostream<CharT, Traits>& operator<<(
      basic_ostream<CharT, Traits>& os, const address& addr);

[function_effects Outputs the string representation of the address to the
stream, as if it were implemented as follows:
``
  error_code ec;
  string s = addr.to_string(ec);
  if (ec)
  {
    if (os.exceptions() & ios_base::failbit)
      throw system_error(ec);
    else
      os.setstate(ios_base::failbit);
  }
  else
    for (string::iterator i = s.begin(); i != s.end(); ++i)
      os << os.widen(*i);
``]

[function_returns `os`.]

[endsect]

[endsect]
